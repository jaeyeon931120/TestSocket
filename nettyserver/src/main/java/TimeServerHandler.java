import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.*;

@ChannelHandler.Sharable
public class TimeServerHandler extends ChannelInboundHandlerAdapter {

    @Override
    public void channelActive(final ChannelHandlerContext ctx){
        final ByteBuf msg = ctx.alloc().buffer(4);
        String msgArr = "0x53 0x01 0x00 0x0F 0x69 0xB8 0x00 0x01 0x2F 0xD1 "
                + "0x00 0x23 0x31 0x35 0x12 0x32 0x30 0x32 0x32 0x30 "
                + "0x31 0x30 0x37 0x31 0x31 0x31 0x37 0x33 0x31 0x1F "
                + "0x00 0x00 0x03 0xE8 0x42 0xCA 0x38 0x52 0x00 0x00 "
                + "0x00 0x00 0x03 0xE8 0x42 0xCA 0x38 0x52 0x00 0x00 "
                + "0x12 0x34 0x00 0x00 0x08 0x00 0x00 0x00 0x12 0x34 "
                + "0x00 0x00 0x07 0x00 0x12 0x34 0x56 0x78 0x23 0x45 "
                + "0x00 0x00 0x07 0x00 0x12 0x34 0x56 0x78 0x23 0x45 "
                + "0x67 0x89 0x12 0x34 0x56 0x78 0x00 0x00 0x06 0x00 "
                + "0x54 0x62 0xBF";
        msg.writeBytes(msgArr.getBytes());

        final ChannelFuture f = ctx.writeAndFlush(msg);
        f.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture Future) {
                assert f == Future;
                ctx.close();
            }
        });
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}